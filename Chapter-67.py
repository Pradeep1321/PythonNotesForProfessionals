"""
Generators are lazy iterators created by generator functions (using yield) or generator expressions (using
(an_expression for x in an_iterator)).

Section 67.1: Introduction
Generator expressions are similar to list, dictionary and set comprehensions, but are enclosed with parentheses.
The parentheses do not have to be present when they are used as the sole argument for a function call.

Generator functions are similar to regular functions, except that they have one or more yield statements in their
body. Such functions cannot return any values (however empty returns are allowed if you want to stop the
generator early).

Calling a generator function produces a generator object, which can later be iterated over. Unlike other types of
iterators, generator objects may only be traversed once.

g1 = function()
print(g1) # Out: <generator object function at 0x1012e1888>

Notice that a generator's body is not immediately executed: when you call function() in the example above, it
immediately returns a generator object, without executing even the first print statement. This allows generators to
consume less memory than functions that return a list, and it allows creating generators that produce infinitely long
sequences.


Since generator objects are iterators, one can iterate over them manually using the next() function. Doing so will
return the yielded values one by one on each subsequent invocation.
If Python reaches the end of the generator function without encountering any more yields, a StopIteration
exception is raised (this is normal, all iterators behave in the same way).

Note that in Python 2 generator objects had .next() methods that could be used to iterate through the yielded
values manually. In Python 3 this method was replaced with the .__next__() standard for all iterators.

Resetting a generator

Remember that you can only iterate through the objects generated by a generator once. If you have already iterated
through the objects in a script, any further attempt do so will yield None.

If you need to use the objects generated by a generator more than once, you can either define the generator
GoalKicker.com – Python® Notes for Professionals 336
function again and use it a second time, or, alternatively, you can store the output of the generator function in a list
on first use.

Section 67.2: Infinite sequences
You can use generator comprehensions on infinite generators to produce new generators:

Be aware that an infinite generator does not have an end, so passing it to any function that will attempt to consume
the generator entirely will have dire consequences:
list(multiples_of_two) # will never terminate, or raise an OS-specific error
Instead, use list/set comprehensions with range (or xrange for python < 3.0):


Section 67.3: Sending objects to a generator

In addition to receiving values from a generator, it is possible to send an object to a generator using the send()
method.

Section 67.4: Yielding all values from another iterable
Python 3.x Version ≥ 3.3
Use yield from if you want to yield all values from another iterable:

Section 67.5: Iteration
A generator object supports the iterator protocol. That is, it provides a next() method (__next__() in Python 3.x),
which is used to step through its execution, and its __iter__ method returns itself. This means that a generator can
be used in any language construct which supports generic iterable objects.

Section 67.6: The next() function
The next() built-in is a convenient wrapper which can be used to receive a value from any iterator (including a
generator iterator) and to provide a default value in case the iterator is exhausted.


The syntax is next(iterator[, default]). If iterator ends and a default value was passed, it is returned. If no
default was provided, StopIteration is raised.

Section 67.7: Coroutines
Generators can be used to implement coroutines
Coroutines are commonly used to implement state machines, as they are primarily useful for creating singlemethod
procedures that require a state to function properly. They operate on an existing state and return the value
obtained on completion of the operation.

Section 67.8: Refactoring list-building code
If the logic is recursive, use yield from to include all the values from the recursive call in a "flattened" result:
def preorder_traversal(node):
    yield node.value
    for child in node.children:
        yield from preorder_traversal(child)

Section 67.9: Yield with recursion: recursively listing all files in a directory

Section 67.10: Generator expressions
It's possible to create generator iterators using a comprehension-like syntax.
The parenthesis from the function call implicitly make your expression a generator expression.

generator = (i * 2 for i in range(3))
next(generator) # 0
next(generator) # 2
next(generator) # 4
next(generator) # raises StopIteration

Section 67.11: Using a generator to find Fibonacci Numbers

Section 67.12: Searching

Section 67.13: Iterating over generators in parallel
To iterate over several generators in parallel, use the zip builtin:
In python 2 you should use itertools.izip instead. Here we can also see that the all the zip functions yield tuples
Note that zip will stop iterating as soon as one of the iterables runs out of items. If you'd like to iterate for as long as
the longest iterable, use itertools.zip_longest().


"""
import itertools
from itertools import islice

#Section 67.2: Infinite sequences
print("--------Section 67.2: Infinite sequences--------")

def integers_starting_from(n):
    while True:
        yield n
        n += 1
natural_numbers = integers_starting_from(1)
#or
#natural_numbers = itertools.count(1)

#You can use generator comprehensions on infinite generators to produce new generators:
multiples_of_two = (x * 2 for x in natural_numbers)
multiples_of_three = (x for x in natural_numbers if x % 3 == 0)


multiples_of_four = (x * 4 for x in integers_starting_from(1))
first_five_multiples_of_four = list(islice(multiples_of_four, 5))

#Classic example - Fibonacci numbers
def fibonacci():
    a, b = 1, 1
    while True:
        yield a
        a, b = b, a + b
first_ten_fibs = list(itertools.islice(fibonacci(), 10))
print(first_ten_fibs)
def nth_fib(n):
    return next(itertools.islice(fibonacci(), n - 1, n))
ninety_nineth_fib = nth_fib(99)
print(ninety_nineth_fib)

#Section 67.3: Sending objects to a generator
print("-----Section 67.3: Sending objects to a generator---------")
def accumulator():
    total = 0
    value = None
    while True:
        # receive sent value
        value = yield total
        if value is None: break
        # aggregate values
        total += value
generator = accumulator()
# advance until the first "yield"
next(generator) # 0
# from this point on, the generator aggregates values
generator.send(1) # 1
generator.send(10) # 11
generator.send(100) # 111
# Calling next(generator) is equivalent to calling generator.send(None)
#next(generator) # StopIteration


#Section 67.4: Yielding all values from another iterable
print("---------Section 67.4: Yielding all values from another iterable-------")


def foob(x):
    yield from range(x * 2)
    yield from range(2)

print(list(foob(5))) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1]

def fibto(n):
    a, b = 1, 1
    while True:
        if a >= n: break
        yield a
        a, b = b, a + b

def usefib():
    yield from fibto(10)
    yield from fibto(20)

print(list(usefib()) )# [1, 1, 2, 3, 5, 8, 1, 1, 2, 3, 5, 8, 13]

#Section 67.5: Iteration
print("--------Section 67.5: Iteration--------")
# naive partial implementation of the Python 2.x xrange()
def xrange(n):
    i = 0
    while i < n:
        yield i
        i += 1
# looping
for i in xrange(10):
    print(i) # prints the values 0, 1, ..., 9
# unpacking
a, b, c = xrange(3) # 0, 1, 2
# building a list
l = list(xrange(10)) # [0, 1, ..., 9]

#Section 67.6: The next() function
print("------Section 67.6: The next() function-------")
def nums():
    yield 1
    yield 2
    yield 3
generator = nums()
next(generator, None) # 1
next(generator, None) # 2
next(generator, None) # 3
next(generator, None) # None
next(generator, None) # None

#Section 67.7: Coroutines
print("-------Section 67.7: Coroutines-------")

# create and advance generator to the first yield
def coroutine(func):
    def start(*args,**kwargs):
        cr = func(*args,**kwargs)
        next(cr)
        return cr
    return start
# example coroutine
@coroutine
def adder(sum = 0):
    while True:
        print(sum)
        x = yield sum
        print("----")
        print(sum)
        print(x)
        sum += x
        print("++++++++++")
# example use
s = adder(10)
s.send(1) # 1
s.send(2) # 3
print(s.send(5))

#Section 67.8: Refactoring list-building code
print("-------Section 67.8: Refactoring list-building code-----------")
#If the logic is recursive, use yield from to include all the values from the recursive call in a "flattened" result:

#Section 67.9: Yield with recursion: recursively listing all files in a directory
print("-------Section 67.9: Yield with recursion: recursively listing all files in a directory------")
from os import listdir
from os.path import isfile, join, exists

path = "C:\\Data\\Python\\PythonNotesForProfessionals"

#Section 67.10: Generator expressions
print("----------Section 67.10: Generator expressions----------")

generator = (i * 2 for i in range(3))
next(generator) # 0
next(generator) # 2
next(generator) # 4
#next(generator) # raises StopIteration
#The parenthesis from the function call implicitly make your expression a generator expression.

#Section 67.11: Using a generator to find Fibonacci Numbers
print("----Section 67.11: Using a generator to find Fibonacci Numbers--------")
def fib(a=0,b=1):
    while True:
        yield a
        a,b=b,a+b

f = fib()
print(', '.join(str(next(f)) for _ in range(10)))

#Section 67.12: Searching
print("-----Section 67.12: Searching------")


